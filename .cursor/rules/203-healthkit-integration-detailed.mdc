---
description: "HealthKit & WorkoutKit é›†æˆè§„èŒƒ - è¯¦ç»†å‚è€ƒ"
scopes: [chat, edit]
tags: [healthkit, workoutkit, ios, health-apps, epoch, detailed-reference]
priority: 203
globs: []
alwaysApply: false
---

# HealthKit & WorkoutKit é›†æˆè§„èŒƒï¼ˆè¯¦ç»†å‚è€ƒï¼‰

> **æ³¨æ„**ï¼šæœ¬æ–‡ä»¶ä¸ºè¯¦ç»†å‚è€ƒï¼Œä¸ä¼šè‡ªåŠ¨åŠ è½½ã€‚  
> **HealthKit æ£€æŸ¥æ¸…å•**ï¼šè§ `101-healthkit-checklist.mdc`  
> **æ ¸å¿ƒçº¦æŸ**ï¼šè§ `000-critical-rules.mdc` çš„"ä¸‰å¤§é“å¾‹"

---

> **Epoch é¡¹ç›®ç‰¹æ®Šè¦æ±‚**ï¼šHealthKit ç­–ç•¥ä¸º"è¯»å–è®°å½• + å†™å…¥è®¡åˆ’"  
> è¯¦è§ï¼š`docs/03-decisions/001-healthkit-read-only.md`

---

## ğŸ¯ Epoch é¡¹ç›®çº¦æŸ

### HealthKit æ•°æ®ç­–ç•¥
- âœ… **è¯»å–è®­ç»ƒè®°å½•**ï¼šä» HealthKit è¯»å–ç”¨æˆ·çš„å†å²è®­ç»ƒæ•°æ®
- âœ… **å†™å…¥è®­ç»ƒè®¡åˆ’**ï¼šä½¿ç”¨ WorkoutKit å†™å…¥æœªæ¥çš„è®­ç»ƒè®¡åˆ’
- âŒ **ç¦æ­¢ä¿®æ”¹è®°å½•**ï¼šæ°¸ä¸ä¿®æ”¹æˆ–åˆ é™¤ HealthKit ä¸­å·²å®Œæˆçš„è®­ç»ƒè®°å½•
- âŒ **ç¦æ­¢å¤åˆ¶æ•°æ®**ï¼šä¸åœ¨ Firebase ä¸­å®Œæ•´å¤åˆ¶ HealthKit æ•°æ®ï¼Œåªå­˜ `healthKitWorkoutId`

### WorkoutKit æ”¯æŒ
- **MVP é˜¶æ®µ**ï¼šæš‚ä¸å®ç° WorkoutKit åŠŸèƒ½
- **V1.1**ï¼šå®ç°è®­ç»ƒè®¡åˆ’åŒæ­¥åˆ° Apple Watch
- **å‚è€ƒ**ï¼š`docs/04-implementation/healthkit-integration.md`

### æ€§èƒ½è¦æ±‚
- **HealthKit æŸ¥è¯¢**ï¼š<100msï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
- **åå°åŒæ­¥**ï¼šä¸é˜»å¡ UI
- **å¢é‡åŒæ­¥**ï¼šåªæŸ¥è¯¢å¢é‡æ•°æ®ï¼Œä¸å…¨é‡æŸ¥è¯¢

---

## ğŸ¥ HealthKit Integration

### Authorization Management

**Request Authorization Once:**
- **Up-front authorization** or just-in-time on user-initiated paths
- **Never inside hot/background query paths**
- **Reference**: [HKHealthStore.requestAuthorization](https://developer.apple.com/documentation/healthkit/hkhealthstore/1614175-requestauthorization)

**Include All Required Types (Epoch ä¸“ç”¨):**
```swift
// Epoch é¡¹ç›®éœ€è¦çš„ HealthKit æ•°æ®ç±»å‹
let typesToRead: Set<HKObjectType> = [
    // è®­ç»ƒæ•°æ®ï¼ˆæ ¸å¿ƒï¼‰
    HKObjectType.workoutType(),
    HKObjectType.quantityType(forIdentifier: .distanceWalkingRunning)!,
    HKObjectType.quantityType(forIdentifier: .activeEnergyBurned)!,
    
    // å¿ƒç‡æ•°æ®
    HKObjectType.quantityType(forIdentifier: .heartRate)!,
    HKObjectType.quantityType(forIdentifier: .restingHeartRate)!,
    HKObjectType.quantityType(forIdentifier: .heartRateVariabilitySDNN)!,
    
    // iOS 18+ æ–°å¢å­—æ®µ
    HKObjectType.quantityType(forIdentifier: .workoutEffortScore),  // RPE
    HKObjectType.quantityType(forIdentifier: .heartRateRecoveryOneMinute)
]

// Epoch éœ€è¦å†™å…¥çš„æ•°æ®ç±»å‹ï¼ˆWorkoutKit - V1.1ï¼‰
let typesToWrite: Set<HKSampleType> = [
    HKObjectType.workoutType()  // è®­ç»ƒè®¡åˆ’
]
```

**Info.plist Configuration:**
```xml
<!-- Info.plist -->
<key>NSHealthShareUsageDescription</key>
<string>Epoch éœ€è¦è¯»å–æ‚¨çš„è®­ç»ƒè®°å½•ï¼Œä»¥ç”Ÿæˆä¸ªæ€§åŒ–çš„è®­ç»ƒè®¡åˆ’å’Œåˆ†ææ‚¨çš„è®­ç»ƒè¿›åº¦ã€‚</string>

<key>NSHealthUpdateUsageDescription</key>
<string>Epoch éœ€è¦å°†è®­ç»ƒè®¡åˆ’å†™å…¥ HealthKitï¼Œä»¥ä¾¿åœ¨ Apple Watch ä¸Šæ˜¾ç¤ºå’Œæé†’ã€‚</string>
```
- **Reference**: [Info.plist HealthKit keys](https://developer.apple.com/documentation/bundleresources/information_property_list/nshealthshareusagedescription)

**Entitlements:**
- **`com.apple.developer.healthkit`** - Basic HealthKit access
- **`com.apple.developer.healthkit.access`** - When needed for specific access
- **`com.apple.developer.healthkit.background-delivery`** - If observers run in background
- **Do not add undocumented entitlements**
- **Reference**: [HealthKit entitlements](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_healthkit)

---

## ğŸ“Š Data Querying Patterns

### Availability & Authorization Checks

```swift
// Always check availability first
guard HKHealthStore.isHealthDataAvailable() else {
    // Handle unavailable case (e.g., iPad without HealthKit)
    throw HealthKitError.notAvailable
}

// Check cached authorization state
let authStatus = healthStore.authorizationStatus(for: type)
guard authStatus == .sharingAuthorized else {
    if authStatus == .notDetermined {
        // Request authorization
        try await requestAuthorization()
    } else {
        // Handle denied case
        throw HealthKitError.authorizationDenied
    }
    return
}
```

### Query Types & Units

**Query Types:**
- **`HKSampleQuery`** - For sample data ([doc](https://developer.apple.com/documentation/healthkit/hksamplequery))
- **`HKStatisticsQuery`** - For aggregated data ([doc](https://developer.apple.com/documentation/healthkit/hkstatisticsquery))
- **`HKWorkoutRouteQuery`** - For workout routes ([doc](https://developer.apple.com/documentation/healthkit/hkworkoutroutequery))

**Correct Units (Epoch ä¸“ç”¨):**
- **Heart Rate**: `count()/min` (beats per minute)
- **HRV SDNN**: `secondUnit(milli)` (milliseconds)
- **Distance**: `meter`
- **Energy**: `kilocalorie`
- **RPE (Workout Effort Score)**: dimensionless (1-10)

### Modern Query Patterns (iOS 18+)

```swift
// âœ… iOS 18+ HKSampleQueryDescriptor (æ¨è)
func fetchRecentWorkouts(limit: Int = 20) async throws -> [HKWorkout] {
    let descriptor = HKSampleQueryDescriptor(
        sampleType: HKObjectType.workoutType(),
        predicate: HKQuery.predicateForWorkouts(with: .running),  // åªæŸ¥è¯¢è·‘æ­¥
        sortDescriptors: [
            NSSortDescriptor(
                key: HKSampleSortIdentifierStartDate,
                ascending: false
            )
        ],
        limit: limit
    )
    
    let results = try await descriptor.result(for: healthStore)
    return results as? [HKWorkout] ?? []
}

// âœ… Epoch å¢é‡åŒæ­¥ç­–ç•¥
func fetchIncrementalWorkouts(since date: Date) async throws -> [HKWorkout] {
    let predicate = NSCompoundPredicate(andPredicateWithSubpredicates: [
        HKQuery.predicateForWorkouts(with: .running),
        HKQuery.predicateForSamples(
            withStart: date,
            end: nil,
            options: .strictStartDate
        )
    ])
    
    let descriptor = HKSampleQueryDescriptor(
        sampleType: HKObjectType.workoutType(),
        predicate: predicate,
        sortDescriptors: [
            NSSortDescriptor(
                key: HKSampleSortIdentifierStartDate,
                ascending: false
            )
        ]
    )
    
    let results = try await descriptor.result(for: healthStore)
    return results as? [HKWorkout] ?? []
}

// âš ï¸ iOS 17 å…¼å®¹ç‰ˆæœ¬ï¼ˆä½¿ç”¨ continuationï¼‰
func fetchWorkoutsLegacy(limit: Int = 20) async throws -> [HKWorkout] {
    return try await withCheckedThrowingContinuation { continuation in
        let query = HKSampleQuery(
            sampleType: HKObjectType.workoutType(),
            predicate: HKQuery.predicateForWorkouts(with: .running),
            limit: limit,
            sortDescriptors: [
                NSSortDescriptor(
                    key: HKSampleSortIdentifierStartDate,
                    ascending: false
                )
            ]
        ) { _, samples, error in
            if let error = error {
                continuation.resume(throwing: error)
            } else {
                continuation.resume(returning: samples as? [HKWorkout] ?? [])
            }
        }
        healthStore.execute(query)
    }
}
```

### Background Observers (V1.1 åŠŸèƒ½)

```swift
// âš ï¸ MVP é˜¶æ®µæš‚ä¸å®ç°ï¼ŒV1.1 å†å¯ç”¨

// Use HKObserverQuery for real-time updates
let observerQuery = HKObserverQuery(
    sampleType: HKObjectType.workoutType(),
    predicate: HKQuery.predicateForWorkouts(with: .running)
) { _, completionHandler, error in
    // Handle new workout data
    Task {
        await self.syncNewWorkouts()
        completionHandler()
    }
}

// Enable background delivery
healthStore.enableBackgroundDelivery(
    for: HKObjectType.workoutType(),
    frequency: .immediate
) { success, error in
    if success {
        print("âœ… Background delivery enabled")
    } else {
        print("âŒ Failed to enable background delivery: \(error?.localizedDescription ?? "unknown")")
    }
}

// Remember to stop/disable on shutdown
healthStore.disableBackgroundDelivery(for: HKObjectType.workoutType())
healthStore.stop(observerQuery)
```

---

## ğŸƒ WorkoutKit Integration (V1.1 åŠŸèƒ½)

> **âš ï¸ MVP é˜¶æ®µæš‚ä¸å®ç° WorkoutKit åŠŸèƒ½**  
> V1.1 å°†å®ç°è®­ç»ƒè®¡åˆ’åŒæ­¥åˆ° Apple Watch

### Feature Detection

```swift
// Always check support first
guard #available(iOS 17.0, *), WorkoutScheduler.isSupported else {
    // Handle unsupported case
    print("WorkoutKit not supported on this device")
    return
}
```

### Authorization

```swift
// Request authorization once and cache state
let authStatus = await WorkoutScheduler.shared.requestAuthorization()
switch authStatus {
case .authorized:
    // Proceed with workout scheduling
    print("âœ… WorkoutKit authorized")
case .denied:
    // Handle denied case
    print("âŒ WorkoutKit authorization denied")
case .notDetermined:
    // Request authorization
    print("âš ï¸ WorkoutKit authorization not determined")
}
```

### Workout Scheduling

```swift
// Schedule workouts with proper error handling
func scheduleWeekPlan(week: WeekPlan) async throws {
    guard #available(iOS 17.0, *), WorkoutScheduler.isSupported else {
        throw WorkoutKitError.notSupported
    }
    
    do {
        // Convert WeekPlan to WorkoutPlan
        let workoutPlan = convertToWorkoutPlan(week)
        
        try await WorkoutScheduler.shared.schedule(
            workoutPlan,
            at: DateComponents(hour: 6, minute: 0)  // æ—©ä¸Š 6:00 æé†’
        )
        
        print("âœ… Workout scheduled successfully")
    } catch {
        print("âŒ Failed to schedule workout: \(error)")
        throw WorkoutKitError.scheduleFailed(error)
    }
}
```

**Entitlements:** No extra WorkoutKit-specific entitlement required beyond HealthKit; rely on Xcode capabilities.

---

## ğŸ”’ Security & Privacy

### Data Protection (Epoch ç‰¹å®šè¦æ±‚)

- âœ… **HealthKit æ•°æ®ä¸ä¸Šä¼ åˆ°æœåŠ¡å™¨** - åªåœ¨æœ¬åœ°åˆ†æ
- âœ… **AI åˆ†ææ—¶åªä¼ å¿…è¦å­—æ®µ** - è·ç¦»ã€é…é€Ÿã€RPEã€notesï¼ˆä¸ä¼ å¿ƒç‡ç­‰æ•æ„Ÿæ•°æ®ï¼‰
- âœ… **ç”¨æˆ·å¯ä»¥éšæ—¶åˆ é™¤æ‰€æœ‰æ•°æ®**
- âŒ **Never log sensitive health values** in production logs
- âŒ **Never store HealthKit raw data** in Firebase

### Privacyæ‰¿è¯ºï¼ˆå†™å…¥éšç§æ”¿ç­–ï¼‰

```markdown
Epoch éšç§æ‰¿è¯ºï¼š
1. HealthKit æ•°æ®åªåœ¨æœ¬åœ°å¤„ç†ï¼Œä¸ä¸Šä¼ åˆ°æœåŠ¡å™¨
2. AI åˆ†æåªä½¿ç”¨å¿…è¦çš„è®­ç»ƒæŒ‡æ ‡ï¼ˆè·ç¦»ã€é…é€Ÿã€RPEï¼‰ï¼Œä¸åŒ…å«å¿ƒç‡ç­‰æ•æ„Ÿæ•°æ®
3. æ‰€æœ‰æ•°æ®åŠ å¯†å­˜å‚¨
4. ç”¨æˆ·å¯ä»¥éšæ—¶åˆ é™¤æ‰€æœ‰æ•°æ®
5. ä¸ä¼šå‘ç¬¬ä¸‰æ–¹åˆ†äº«æ‚¨çš„å¥åº·æ•°æ®
```

### Concurrency Safety

```swift
// Keep UI-affecting updates on the main actor
@MainActor
func updateUI(with workouts: [HKWorkout]) {
    // Update UI safely
    self.trainingLogs = workouts.map { TrainingLogMapper.fromHealthKit($0) }
}

// Avoid blocking semaphores in hot paths
func processHealthData() async {
    // Use async/await instead of blocking operations
    let workouts = try await fetchRecentWorkouts()
    await MainActor.run {
        updateUI(with: workouts)
    }
}
```

---

## ğŸ§ª Testing Patterns

### Mock HealthKit Data

```swift
// Create mock data for testing
class MockHealthKitService: HealthKitServiceProtocol {
    var mockWorkouts: [HKWorkout] = []
    
    func fetchRecentWorkouts(limit: Int) async throws -> [HKWorkout] {
        return Array(mockWorkouts.prefix(limit))
    }
    
    func fetchIncrementalWorkouts(since date: Date) async throws -> [HKWorkout] {
        return mockWorkouts.filter { $0.startDate > date }
    }
}
```

### Unit Testing

```swift
func testFetchRecentWorkouts() async throws {
    // Given: Mock HealthKit service
    let mockService = MockHealthKitService()
    mockService.mockWorkouts = [
        createMockWorkout(distance: 5000, duration: 1800),
        createMockWorkout(distance: 10000, duration: 3600)
    ]
    
    let viewModel = TrainingLogViewModel(healthKit: mockService)
    
    // When: Fetch workouts
    try await viewModel.fetchRecentLogs()
    
    // Then: Should have 2 logs
    XCTAssertEqual(viewModel.trainingLogs.count, 2)
    XCTAssertEqual(viewModel.trainingLogs[0].distance, 5000)
}

// Helper function to create mock workout
func createMockWorkout(distance: Double, duration: TimeInterval) -> HKWorkout {
    let distanceQuantity = HKQuantity(unit: .meter(), doubleValue: distance)
    let start = Date()
    let end = start.addingTimeInterval(duration)
    
    return HKWorkout(
        activityType: .running,
        start: start,
        end: end,
        duration: duration,
        totalEnergyBurned: nil,
        totalDistance: distanceQuantity,
        metadata: nil
    )
}
```

---

## ğŸ“Š Performance Optimization

### Query Optimization (Epoch ä¸“ç”¨)

```swift
// âœ… ä½¿ç”¨å¢é‡åŒæ­¥ï¼Œé¿å…å…¨é‡æŸ¥è¯¢
func syncWorkouts() async throws {
    let lastSyncDate = UserDefaults.standard.object(forKey: "lastSyncDate") as? Date ?? Date.distantPast
    let newWorkouts = try await fetchIncrementalWorkouts(since: lastSyncDate)
    
    // Only process new workouts
    for workout in newWorkouts {
        try await processWorkout(workout)
    }
    
    // Update last sync date
    UserDefaults.standard.set(Date(), forKey: "lastSyncDate")
}

// âœ… ä½¿ç”¨ predicate é™åˆ¶æŸ¥è¯¢èŒƒå›´
func fetchWorkoutsInDateRange(from startDate: Date, to endDate: Date) async throws -> [HKWorkout] {
    let predicate = NSCompoundPredicate(andPredicateWithSubpredicates: [
        HKQuery.predicateForWorkouts(with: .running),
        HKQuery.predicateForSamples(
            withStart: startDate,
            end: endDate,
            options: .strictStartDate
        )
    ])
    
    let descriptor = HKSampleQueryDescriptor(
        sampleType: HKObjectType.workoutType(),
        predicate: predicate,
        sortDescriptors: [
            NSSortDescriptor(key: HKSampleSortIdentifierStartDate, ascending: false)
        ]
    )
    
    let results = try await descriptor.result(for: healthStore)
    return results as? [HKWorkout] ?? []
}

// âœ… ç¼“å­˜é¢‘ç¹è®¿é—®çš„æ•°æ®ï¼ˆä½¿ç”¨ SwiftDataï¼‰
actor HealthKitCacheService {
    func getCachedWorkouts(limit: Int = 14) throws -> [CachedTrainingLog] {
        // ä» SwiftData è¯»å–æœ€è¿‘ 14 å¤©çš„ç¼“å­˜
        let descriptor = FetchDescriptor<CachedTrainingLog>(
            predicate: #Predicate { log in
                log.date > Date().addingTimeInterval(-14 * 24 * 3600)
            },
            sortBy: [SortDescriptor(\.date, order: .reverse)]
        )
        return try modelContext.fetch(descriptor)
    }
}
```

### Memory Management

```swift
// âœ… Release query objects when done
func fetchWorkouts() async throws -> [HKWorkout] {
    let workouts = try await fetchRecentWorkouts(limit: 20)
    // Query is automatically released after completion
    return workouts
}

// âœ… Use weak references in completion handlers
class HealthKitManager {
    func setupObserver() {
        let query = HKObserverQuery(...) { [weak self] _, completion, error in
            self?.handleNewData()
            completion()
        }
        healthStore.execute(query)
    }
}

// âœ… Implement proper cleanup in deinit
actor HealthKitService {
    private var activeQueries: [HKQuery] = []
    
    deinit {
        // Stop all active queries
        for query in activeQueries {
            healthStore.stop(query)
        }
    }
}
```

---

## ğŸš¨ Error Handling

### Epoch Custom Error Types

```swift
enum HealthKitError: Error, LocalizedError {
    case notAvailable
    case authorizationDenied
    case queryFailed(Error)
    case dataCorrupted
    case incrementalSyncFailed
    
    var errorDescription: String? {
        switch self {
        case .notAvailable:
            return LocalizedString.Errors.healthKitNotAvailable
        case .authorizationDenied:
            return LocalizedString.Errors.healthKitAuthDenied
        case .queryFailed(let error):
            return LocalizedString.Errors.healthKitQueryFailed(error.localizedDescription)
        case .dataCorrupted:
            return LocalizedString.Errors.healthKitDataCorrupted
        case .incrementalSyncFailed:
            return LocalizedString.Errors.healthKitSyncFailed
        }
    }
}

enum WorkoutKitError: Error, LocalizedError {
    case notSupported
    case scheduleFailed(Error)
    
    var errorDescription: String? {
        switch self {
        case .notSupported:
            return LocalizedString.Errors.workoutKitNotSupported
        case .scheduleFailed(let error):
            return LocalizedString.Errors.workoutKitScheduleFailed(error.localizedDescription)
        }
    }
}
```

### Common Error Scenarios

```swift
func handleHealthKitError(_ error: Error) {
    switch error {
    case let hkError as HKError:
        switch hkError.code {
        case .errorHealthDataUnavailable:
            // HealthKit ä¸å¯ç”¨ï¼ˆå¦‚ iPadï¼‰
            showAlert(LocalizedString.Errors.healthKitNotAvailable)
        case .errorAuthorizationDenied:
            // ç”¨æˆ·æ‹’ç»æˆæƒ
            showAuthorizationPrompt()
        case .errorDatabaseInaccessible:
            // æ•°æ®åº“ä¸å¯è®¿é—®ï¼ˆè®¾å¤‡é”å®šï¼‰
            showAlert(LocalizedString.Errors.deviceLocked)
        default:
            // å…¶ä»–é”™è¯¯
            showAlert(hkError.localizedDescription)
        }
    default:
        // å…¶ä»–é”™è¯¯
        showAlert(error.localizedDescription)
    }
}
```

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

### Epoch é¡¹ç›®æ–‡æ¡£
- **ADR-001**: `docs/03-decisions/001-healthkit-read-only.md` - HealthKit ç­–ç•¥å†³ç­–
- **HealthKit é›†æˆ**: `docs/04-implementation/healthkit-integration.md` - è¯¦ç»†å®ç°æ–‡æ¡£
- **æ•°æ®æ¨¡å‹**: `docs/04-implementation/swiftdata-schema.md` - SwiftData æ¨¡å‹è®¾è®¡

### Apple å®˜æ–¹æ–‡æ¡£
- **HealthKit Documentation**: https://developer.apple.com/documentation/healthkit
- **WorkoutKit**: https://developer.apple.com/documentation/workoutkit
- **HKHealthStore**: https://developer.apple.com/documentation/healthkit/hkhealthstore
- **HKSampleQueryDescriptor**: https://developer.apple.com/documentation/healthkit/hksamplequerydescriptor

---

**Remember**: HealthKit and WorkoutKit integration requires careful attention to user privacy, proper authorization handling, and efficient data processing. For Epoch project, always follow the "read records + write plans" strategy and never modify completed workout data.

---

**æœ€åæ›´æ–°**: 2025-11-03  
**ç‰ˆæœ¬**: 1.0  
**Epoch ä¸“ç”¨çº¦æŸ**: HealthKit åªè¯»è®­ç»ƒè®°å½•ï¼ŒWorkoutKit å†™å…¥è®¡åˆ’ï¼ˆV1.1ï¼‰

