---
description: "结构化决策支持 - 详细参考（8维评估、ADR方法论、案例库）"
scopes: [chat, edit]
tags: [decision-framework, evaluation-matrix, adr-methodology, case-studies]
priority: 208
globs: []
alwaysApply: false
---

# 结构化决策支持 - 详细参考

> **重要性**: ⭐⭐⭐⭐ 高优先级  
> **加载方式**: 手动加载（按需）  
> **简化版**: `003-structured-decision-workflow.mdc`  
> **用途**: 深入的决策框架、评估维度、案例参考  

---

## 📐 完整决策框架

### 基于 ADR（架构决策记录）方法论

**核心原则**：
1. **单一决策原则** - 每个疑点聚焦一个决策点
2. **结论先行** - 金字塔原理，先给推荐，再说理由
3. **证据驱动** - 基于数据、测试、历史案例
4. **可追溯性** - 所有决策可回溯，记录在 ADR 中
5. **可逆性评估** - 明确决策的可逆成本

### 决策流程图

```
用户提出复杂问题
    ↓
AI 识别为复杂问题（满足触发场景）
    ↓
询问用户："是否使用结构化决策流程？"
    ↓
用户确认 → 开始流程
    ↓
┌─────────────────────────────────────────────┐
│ 1️⃣ 疑点识别 (Problem Decomposition)        │
│   - 分解为 2-5 个独立疑点                    │
│   - 按重要性排序                             │
│   - 明确每个疑点的不确定性                   │
└─────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────┐
│ 2️⃣ 方案生成 (Solution Generation)          │
│   对每个疑点：                               │
│   - 生成 2-3 个候选方案                      │
│   - 使用 8 维评估矩阵打分                    │
│   - 计算综合推荐度（⭐1-5）                  │
│   - 明确推荐理由 + 不推荐理由                │
└─────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────┐
│ 3️⃣ 逐项讨论 (Iterative Discussion)         │
│   - 一次只讨论 1 个疑点                      │
│   - 等待用户明确决策                         │
│   - 标记状态：✅ 已决策 / 🔄 讨论中 / ⏸️  暂缓│
│   - 记录决策依据                             │
└─────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────┐
│ 4️⃣ 综合整合 (Synthesis & Integration)      │
│   - 输出决策摘要表                           │
│   - 生成实施计划大纲                         │
│   - 列出综合风险清单                         │
│   - 关联文档索引（ADR、实施文档）            │
└─────────────────────────────────────────────┘
    ↓
用户批准 → AI 执行实施计划
    ↓
遵循 207-task-execution-detailed.mdc
```

---

## 📊 8 维评估矩阵

### 评估维度定义

每个方案从 8 个维度评估，每个维度 0-10 分：

#### 1️⃣ 技术可行性 (Technical Feasibility)

**评分标准**：
- **9-10 分**：基于已有技术栈，无技术风险，团队完全掌握
- **7-8 分**：技术成熟，有官方文档，需少量学习
- **5-6 分**：技术可行，但需深入研究，有一定风险
- **3-4 分**：技术新颖，文档不全，需大量试错
- **0-2 分**：技术未验证，可能不可行，需原型验证

**评估问题**：
- 是否基于项目现有技术栈？（Swift 6.2, iOS 26, Firebase, SwiftData）
- 团队是否熟悉相关技术？
- 是否有官方文档和最佳实践？
- 是否需要引入新的第三方库？（需创建 ADR）

#### 2️⃣ 实现成本 (Implementation Cost)

**评分标准**：
- **9-10 分**：<1 天，单文件修改，无依赖变更
- **7-8 分**：1-3 天，2-5 个文件，小范围重构
- **5-6 分**：3-7 天，5-10 个文件，中等重构
- **3-4 分**：1-2 周，>10 个文件，大范围重构
- **0-2 分**：>2 周，架构级重构，需多轮迭代

**评估问题**：
- 需要修改多少个文件？
- 是否需要数据迁移？（SwiftData Schema 变更）
- 是否需要更新 Backend API？
- 是否需要更新 Firebase Security Rules？

#### 3️⃣ 时间紧迫度 (Time Urgency)

**评分标准**：
- **9-10 分**：完全符合当前 Week 目标，无时间压力
- **7-8 分**：可在当前 Week 完成，时间充裕
- **5-6 分**：需占用当前 Week 大部分时间，略紧张
- **3-4 分**：会延迟当前 Week 进度，需调整计划
- **0-2 分**：严重延迟，不适合当前阶段

**评估问题**：
- 当前处于 Week X/12，MVP 目标是什么？
- 这个方案是否符合 MVP 原则？（先丑后美，快速验证）
- 是否会阻塞其他关键功能？
- 是否可以分阶段实现？（MVP → 优化 → 完善）

#### 4️⃣ 风险等级 (Risk Level)

**评分标准**（分数越高，风险越低）：
- **9-10 分**：无风险，已验证方案，可回滚
- **7-8 分**：低风险，有降级方案，影响范围小
- **5-6 分**：中风险，需测试验证，影响部分功能
- **3-4 分**：高风险，可能引入新问题，难以回滚
- **0-2 分**：极高风险，可能破坏核心功能，不可逆

**评估问题**：
- 是否会影响已有功能？（回归测试范围）
- 是否会影响数据完整性？（HealthKit 只读、Firebase 备份）
- 是否可以快速回滚？（Git revert 即可 vs 需数据迁移）
- 是否有降级方案？（Feature Flag, A/B Testing）

#### 5️⃣ 可维护性 (Maintainability)

**评分标准**：
- **9-10 分**：代码清晰，符合规范，易于理解和修改
- **7-8 分**：结构合理，有文档，维护成本低
- **5-6 分**：可维护，但需熟悉业务逻辑
- **3-4 分**：复杂度高，难以理解，维护成本高
- **0-2 分**：技术债务严重，难以扩展，建议重构

**评估问题**：
- 是否符合项目编码规范？（202-swift-standards-detailed.mdc）
- 是否有清晰的 Protocol 抽象？（Service → Protocol + Mock）
- 是否有单元测试覆盖？（核心逻辑 ≥75%）
- 是否有文档？（ADR + 实施文档 + Changelog）

#### 6️⃣ 可扩展性 (Scalability)

**评分标准**：
- **9-10 分**：易于扩展，架构灵活，符合 SOLID 原则
- **7-8 分**：可扩展，无明显瓶颈
- **5-6 分**：基本可扩展，需小幅调整
- **3-4 分**：扩展困难，需重构部分代码
- **0-2 分**：不可扩展，需完全重写

**评估问题**：
- 未来需求变化时，是否易于扩展？
- 是否遵循开闭原则？（对扩展开放，对修改关闭）
- 是否有明显的性能瓶颈？（<2s 启动、<5s AI 反馈、<100ms 缓存）
- 是否支持并发和异步？（async/await, actor）

#### 7️⃣ 用户价值 (User Value)

**评分标准**：
- **9-10 分**：核心功能，用户强需求，直接提升体验
- **7-8 分**：重要功能，用户有需求，提升满意度
- **5-6 分**：有价值，但非核心，锦上添花
- **3-4 分**：价值有限，用户感知不强
- **0-2 分**：无明显价值，过度设计

**评估问题**：
- 这个功能是否解决用户痛点？
- 是否符合产品原则？（206-product-principles-detailed.mdc）
- 是否有数据支持？（用户反馈、调研、竞品分析）
- 是否符合 MVP 定义？（Minimum Viable Product）

#### 8️⃣ 符合项目原则 (Alignment with Principles)

**评分标准**：
- **9-10 分**：完全符合所有项目原则和规范
- **7-8 分**：基本符合，有少量偏差
- **5-6 分**：部分符合，需调整以符合规范
- **3-4 分**：偏离原则，需重新设计
- **0-2 分**：严重违反原则（如：修改 HealthKit 记录）

**评估清单**：
- [ ] 是否符合三大铁律？（000-critical-rules.mdc）
  - ❌ 修改 HealthKit 训练记录 → 直接 0 分
  - ❌ 违反 UESCA 原则 → 直接 0 分
  - ❌ 性能指标不达标 → 扣 3-5 分
- [ ] 是否符合防过度设计原则？（204-anti-overengineering-detailed.mdc）
- [ ] 是否符合质量保证原则？（205-quality-assurance-detailed.mdc）
- [ ] 是否符合产品设计原则？（206-product-principles-detailed.mdc）

### 综合推荐度计算

**公式**：
```
综合得分 = Σ(维度得分 × 权重) / 10

权重分配（总和 = 1.0）：
- 技术可行性：0.20（最重要，不可行则全盘否定）
- 实现成本：0.15
- 时间紧迫度：0.15（MVP 阶段重要）
- 风险等级：0.15
- 可维护性：0.10
- 可扩展性：0.10
- 用户价值：0.10
- 符合原则：0.05（但如果 <5 分，直接否决）

推荐度映射：
- 9.0-10.0 → ⭐⭐⭐⭐⭐（强烈推荐）
- 7.5-8.9  → ⭐⭐⭐⭐（推荐）
- 6.0-7.4  → ⭐⭐⭐（可选）
- 4.5-5.9  → ⭐⭐（不推荐）
- 0.0-4.4  → ⭐（强烈不推荐）
```

**示例**：
```markdown
方案 A: 使用 SwiftData 本地缓存
- 技术可行性：10（已使用，团队熟悉）× 0.20 = 2.0
- 实现成本：9（1天，单文件）× 0.15 = 1.35
- 时间紧迫度：10（符合 Week 8）× 0.15 = 1.5
- 风险等级：9（已验证，可回滚）× 0.15 = 1.35
- 可维护性：8（代码清晰）× 0.10 = 0.8
- 可扩展性：7（基本可扩展）× 0.10 = 0.7
- 用户价值：8（提升性能）× 0.10 = 0.8
- 符合原则：10（完全符合）× 0.05 = 0.5
----------------------------------------
综合得分：9.0 → ⭐⭐⭐⭐⭐（强烈推荐）
```

---

## 📋 方案对比输出格式

### 渐进式展示原则 ⭐ 最佳实践

**核心理念**：默认简洁，可选详细

**问题**：完整的 8 维评估表格虽然专业透明，但会导致：
- ❌ 篇幅过长（每个疑点 ~35 行）
- ❌ 视觉干扰（表格打断阅读流）
- ❌ 移动端显示差
- ❌ 用户阅读疲劳

**解决方案**：使用 `<details>` 标签折叠表格

---

### 标准输出格式

```markdown
#### ❓ 疑点 X: [具体描述]

**💡 推荐**: 方案 B - 综合得分 9.1 ⭐⭐⭐⭐⭐

**📝 推荐理由**:
1. [理由 1]
2. [理由 2]
3. [理由 3]
4. [理由 4]

**⚠️ 不推荐理由**:
- 方案 A: [为什么不推荐]
- 方案 C: [为什么不推荐]

**📊 证据支持**:
- [引用规则文件/ADR]
- [工作量估算]
- [历史案例]

**📊 评估摘要**:（可选）
- 综合得分：方案 B (9.1) > 方案 C (7.0) > 方案 A (6.6)
- 关键优势：[维度名] +[分数]、[维度名] +[分数]
- 主要劣势：[方案 X] [维度名] 仅 [分数]

<details>
<summary>📊 完整 8 维评估矩阵（点击展开）</summary>

| 评估维度 | 权重 | 方案 A | 方案 B | 方案 C | 说明 |
|---------|------|--------|--------|--------|------|
| ... | ... | ... | ... | ... | ... |

</details>

---
```

**篇幅对比**：
- 默认显示：~18-22 行（减少 45%）
- 可选展开：额外 ~15-20 行（完整表格）

---

### 何时展开表格（默认显示）

**适用场景**：
- ✅ **最关键疑点**（⭐⭐⭐⭐⭐ 优先级最高）
- ✅ **有争议的推荐**（可能不符合用户预期）
- ✅ **首次使用结构化决策**（让用户了解评估方法）
- ✅ **评分差异小**（方案 A 8.5 vs 方案 B 8.7，需要详细对比）

**示例场景**：
- 执行时间点（Week 8 vs Week 9）- 关键决策
- 技术选型（Swift vs Kotlin）- 重大影响
- 架构重构（单体 vs 微服务）- 争议性高

---

### 何时折叠表格（默认折叠）

**适用场景**：
- ✅ **次要疑点**（⚠️ 配置细节级别）
- ✅ **推荐理由已充分**（4-5 条理由 + 证据支持，用户已能做决策）
- ✅ **用户已熟悉评估方法**（非首次使用）
- ✅ **评分差异明显**（方案 A 9.5 vs 方案 B 6.0，结论显而易见）

**示例场景**：
- 语言政策（中文 vs 英文）- 配置细节
- 图表复杂度（简单 vs 详细）- 次要决策
- Linter 规则（严格 vs 宽松）- 可后续调整

---

### 评估摘要格式（替代表格）

当折叠表格时，**必须**提供评估摘要：

```markdown
**📊 评估摘要**:
- 综合得分：方案 B (9.1) > 方案 C (7.0) > 方案 A (6.6)
- 关键优势：时间紧迫度 +10、风险等级 +9、符合原则 +10
- 主要劣势：方案 A 时间紧迫度仅 4 分（会延迟核心功能）
```

**作用**：
- 让用户知道"有评估过"（不是拍脑袋）
- 展示关键差异点（为什么 B 比 A 好）
- 提供快速决策依据

---

## 📋 方案对比模板

### 完整版（用于关键疑点）

```markdown
#### ❓ 疑点：[具体描述]

| 评估维度 | 权重 | 方案 A | 方案 B | 方案 C | 说明 |
|---------|------|--------|--------|--------|------|
| **技术可行性** | 20% | 10 ⭐ | 7 | 4 | A: 已有技术栈；B: 需学习；C: 需验证 |
| **实现成本** | 15% | 9 | 5 | 3 | A: 1天；B: 1周；C: 2周 |
| **时间紧迫度** | 15% | 10 | 6 | 4 | A: 符合当前 Week；B: 会延迟；C: 不适合 |
| **风险等级** | 15% | 9 | 7 | 3 | A: 低风险；B: 中风险；C: 高风险 |
| **可维护性** | 10% | 8 | 9 | 5 | A: 清晰；B: 最优；C: 复杂 |
| **可扩展性** | 10% | 7 | 10 ⭐ | 6 | A: 可扩展；B: 最优；C: 受限 |
| **用户价值** | 10% | 8 | 8 | 7 | A/B: 核心功能；C: 价值有限 |
| **符合原则** | 5% | 10 | 10 | 8 | A/B: 完全符合；C: 基本符合 |
| **综合得分** | - | **9.0** ⭐⭐⭐⭐⭐ | **7.5** ⭐⭐⭐⭐ | **4.7** ⭐⭐ | - |

---

**💡 推荐**: 方案 A

**📝 推荐理由**:
1. **技术可行性最高** - 基于 SwiftData，团队完全掌握，无学习成本
2. **成本和时间最优** - 1 天完成，符合 Week 8 目标，不延迟进度
3. **风险可控** - 已验证方案，可快速回滚，不影响核心功能
4. **综合得分最高** - 9.0 分，远超方案 B（7.5）和方案 C（4.7）

**⚠️ 不推荐理由**:
- **方案 B**: 虽然可扩展性最优（10 分），但实现成本高（5 分），会延迟当前 Week 进度。
  - 根据 204-anti-overengineering 原则："先验证需求，再优化扩展性"
  - MVP 阶段不应为未验证的需求过度设计
  
- **方案 C**: 综合得分低（4.7），技术风险高（3 分），实现成本高（3 分）。
  - 折中方案往往"两头不靠"，既无 A 的快速性，也无 B 的扩展性
  - 技术债务风险高，不符合质量保证原则

**📊 证据支持**:
- ADR-007: 类似场景选择了方案 A 类型（快速迭代 > 过度设计）
- Performance: 方案 A 满足性能指标（<100ms 缓存读取）
- Test: 方案 A 有完整的单元测试覆盖（80%+）
```

---

### 简化版（用于次要疑点）⭐ 推荐

**使用场景**：次要疑点、配置细节、用户已熟悉评估方法

```markdown
#### ❓ 疑点 X: [具体描述] ⚠️

**💡 推荐**: 方案 A（实用主义）- 综合得分 9.0 ⭐⭐⭐⭐⭐

**📝 推荐理由**:
1. **灵活高效** - 不限制作者选择，提升产出效率
2. **符合 MVP 原则** - 不应为未验证的国际化需求限制效率
3. **可升级** - 未来如需国际化，再制定严格规范（有数据支持）
4. **当前团队现状** - 本地中文团队，强制英文降低效率

**⚠️ 不推荐理由**:
- **方案 B（严格规范）**: 过度设计，短期成本高，违反 204 原则

**📊 评估摘要**:
- 综合得分：方案 A (9.0) > 方案 C (7.5) > 方案 B (6.5)
- 关键优势：实现成本 +10、时间紧迫度 +10、符合原则 +10
- 主要劣势：方案 B 短期成本高（需翻译现有文档）

<details>
<summary>📊 完整 8 维评估矩阵（点击展开）</summary>

| 评估维度 | 权重 | 方案 A | 方案 B | 方案 C | 说明 |
|---------|------|--------|--------|--------|------|
| **技术可行性** | 20% | 10 | 8 | 9 | 所有方案可行 |
| **实现成本** | 15% | 10 | 5 | 7 | A: 0h；B: 需翻译；C: 折中 |
| **时间紧迫度** | 15% | 10 | 6 | 8 | A: 立即可用；B: 延迟产出 |
| **风险等级** | 15% | 8 | 7 | 7 | A: 国际化时翻译；B: 限制效率 |
| **可维护性** | 10% | 8 | 9 | 7 | B: 最规范；A: 灵活 |
| **可扩展性** | 10% | 7 | 10 | 8 | B: 利于开源；A: 需后续规范 |
| **用户价值** | 10% | 8 | 7 | 8 | A: 产出效率高 |
| **符合原则** | 5% | 10 | 6 | 9 | A: 符合 MVP；B: 过度设计 |
| **综合得分** | - | **9.0** ⭐⭐⭐⭐⭐ | **6.5** ⭐⭐⭐ | **7.5** ⭐⭐⭐⭐ |

</details>

---
```

**篇幅对比**：
- 默认显示：~18 行
- 完整版展开：~35 行
- **节省 48%** 篇幅

**优势**：
- ✅ 聚焦推荐和理由
- ✅ 保持透明度（表格可选查看）
- ✅ 易读性高
- ✅ 移动端友好

---

## ⚠️ 风险评估矩阵（RAID）

### RAID 模型

**R**isks - 风险  
**A**ssumptions - 假设  
**I**ssues - 问题  
**D**ependencies - 依赖  

### 风险评估模板

```markdown
## ⚠️ 综合风险清单

### 🔴 风险 (Risks)

| 风险描述 | 可能性 | 影响 | 风险等级 | 缓解措施 | 应急预案 | 负责人 |
|---------|--------|------|---------|---------|---------|--------|
| SwiftData 性能不足 | 🟡 中 | 🔴 高 | 🟠 中高 | 提前性能测试 | 降级到 Core Data | AI + User |
| Firebase 配额超限 | 🟢 低 | 🟠 中 | 🟢 低 | 监控 Dashboard | 升级套餐 | User |
| 时间延迟 | 🟡 中 | 🟠 中 | 🟠 中 | 简化功能范围 | 延后非核心功能 | User |

**风险等级计算**：
- 🔴 高 = 可能性高 × 影响高
- 🟠 中 = 可能性中 × 影响高 或 可能性高 × 影响中
- 🟢 低 = 可能性低 × 影响低

---

### 📝 假设 (Assumptions)

| 假设描述 | 验证方式 | 如果假设不成立 |
|---------|---------|---------------|
| 用户设备支持 iOS 18+ | 查看 App Store Connect 数据 | 降低最低版本要求 |
| Firebase 免费套餐足够 MVP | 监控使用量 | 升级付费套餐 |
| SwiftData 性能满足需求 | 性能测试（<100ms） | 切换到 Core Data |

---

### 🐛 已知问题 (Issues)

| 问题描述 | 严重性 | 状态 | 解决方案 | 预计解决时间 |
|---------|--------|------|---------|-------------|
| WeekPlanView 时区问题 | 🟡 中 | ✅ 已修复 | 统一使用 UTC | Week 7 |
| HealthKit 授权流程卡顿 | 🟢 低 | 🔄 进行中 | 异步加载 | Week 8 |

---

### 🔗 依赖 (Dependencies)

| 依赖项 | 类型 | 状态 | 风险 | 备注 |
|-------|------|------|------|------|
| Firebase SDK 11.x | 技术 | ✅ 稳定 | 🟢 低 | 官方支持 Swift 6 |
| HealthKit API | 系统 | ✅ 稳定 | 🟢 低 | iOS 18+ 标准 API |
| OpenAI API | 外部 | ⚠️  依赖 | 🟠 中 | 需降级方案（本地模型）|
```

---

## 📚 历史案例参考（Epoch 项目）

### 案例 1: Onboarding 简化（2025-11-04）

**场景**：Onboarding 从 9 步简化到 5 步

**决策过程**：
- **疑点**：如何降低用户门槛又不失信息完整性？
- **方案对比**：
  - 方案 A: 保持 9 步，优化文案 → ⭐⭐⭐
  - 方案 B: 简化到 5 步，自动填充 HealthKit → ⭐⭐⭐⭐⭐
  - 方案 C: 简化到 3 步，牺牲个性化 → ⭐⭐
- **最终决策**：方案 B
- **理由**：用户价值高（降低门槛）+ 技术可行（HealthKit 自动填充）

**经验教训**：
- ✅ 数据驱动：观察到用户在 Step 4-6 流失率高
- ✅ MVP 原则：先简化，再根据反馈补充
- ⚠️ 避免：过度简化导致信息不足（方案 C）

**相关文档**：
- ADR-008: Onboarding UX Strategy
- Changelog: `docs/07-changelog/2025-11.md`

---

### 案例 2: 数据缓存分层（2025-10-15）

**场景**：设计三层缓存架构（14天 / 90天 / 归档）

**决策过程**：
- **疑点**：如何平衡性能、成本、用户价值？
- **方案对比**：
  - 方案 A: 全部本地缓存 → ⭐⭐（成本高，设备存储受限）
  - 方案 B: 全部云端缓存 → ⭐⭐（性能差，依赖网络）
  - 方案 C: 三层分层架构 → ⭐⭐⭐⭐⭐（折中最优）
- **最终决策**：方案 C
- **理由**：性能最优（Layer 1 <100ms）+ 成本可控 + 支持 Premium

**经验教训**：
- ✅ 符合 80/20 原则：80% 访问集中在 14 天内
- ✅ 分层设计：根据访问频率分配存储策略
- ⚠️ 避免：一刀切方案（全本地或全云端）

**相关文档**：
- `docs/04-implementation/data-caching-strategy.md`
- ADR-006: Data Caching Strategy

---

### 案例 3: 任务执行红线（2025-11-07）

**场景**：Week 6-7 因跳过步骤导致 Bug

**问题**：
- AI 跳过编译验证 → 未发现 WeekPlanView Bug
- AI 跳过真机测试 → 时区问题未暴露

**解决**：
- 创建 207-task-execution-detailed.mdc
- 建立"任务执行红线"：失败时必须停止

**经验教训**：
- ✅ 验收标准必须明确（BUILD SUCCEEDED, 真机测试清单）
- ✅ 失败时立即停止，不得跳过步骤
- ⚠️ 避免：假设"应该没问题"就继续

**相关文档**：
- `docs/09-lessons-learned/2025-11-07_task-execution-lesson.md`
- 207-task-execution-detailed.mdc

---

## 🚫 常见陷阱与误区

### 陷阱 1: 过度设计（Over-engineering）

**表现**：
- 为未验证的需求设计复杂架构
- 过早优化性能（"以后可能需要"）
- 引入过多抽象层（"为了扩展性"）

**识别信号**：
- 方案 B 的可扩展性明显优于方案 A，但实现成本高 2-3 倍
- 用户价值不明确，主要是"技术上更优雅"
- 没有数据支持，只是"觉得应该"

**缓解措施**：
- ✅ 参考 204-anti-overengineering-detailed.mdc
- ✅ 问："这个扩展性是为了解决什么具体问题？"
- ✅ 问："有数据支持这个需求吗？"
- ✅ MVP 原则：先丑后美，先验证再优化

**示例**：
```markdown
❌ 错误决策：
"虽然方案 A（简单实现）能满足需求，但方案 B（复杂架构）可扩展性更好，
 选方案 B 吧，以免将来重构。"

✅ 正确决策：
"方案 A 满足当前需求，实现成本低，风险可控。
 如果未来确实需要扩展（有数据支持），再重构也不迟。
 根据 204 原则，选方案 A。"
```

---

### 陷阱 2: 忽略证据（Ignoring Evidence）

**表现**：
- 基于"感觉"推荐方案，无数据支持
- 忽略历史案例，重复踩坑
- 未验证假设，直接下结论

**识别信号**：
- 推荐理由中没有引用 ADR、测试数据、历史案例
- 使用"应该"、"可能"、"大概"等模糊词汇
- 未设计验证方案就推荐高风险方案

**缓解措施**：
- ✅ 参考 000-critical-rules.mdc 的"辨证思考铁律"
- ✅ 优先实验验证（找不到文档 → 设计测试）
- ✅ 引用证据：ADR-XXX、测试结果、历史案例
- ✅ 承认不确定性："我不知道 X，建议验证"

**示例**：
```markdown
❌ 错误表述：
"方案 A 应该性能更好，推荐使用。"

✅ 正确表述：
"方案 A 理论上性能更优，但需要验证。建议：
 1. 运行性能测试（目标：<100ms 缓存读取）
 2. 对比方案 A 和方案 B 的实测数据
 3. 基于测试结果做最终决策"
```

---

### 陷阱 3: 一次决策多个疑点

**表现**：
- 未等用户确认疑点 1，就直接讨论疑点 2
- 假设"用户可能想选 A"就继续
- 疑点之间有依赖，但未按顺序讨论

**识别信号**：
- 决策进展表中有多个 🔄 讨论中的疑点
- AI 在一个回复中讨论了多个疑点
- 用户对疑点 1 还有疑问，AI 已经开始整合

**缓解措施**：
- ✅ 严格遵循"逐项讨论"原则（3️⃣ 步骤）
- ✅ 每次只讨论 1 个疑点，等待用户明确决策
- ✅ 用户说"继续"或"下一个" → 才标记 ✅，进入下一个
- ✅ 如有依赖，标记 ⏸️  暂缓，先讨论依赖项

---

### 陷阱 4: 忽略项目原则

**表现**：
- 推荐方案违反三大铁律（修改 HealthKit、违反 UESCA、性能不达标）
- 忽略 MVP 原则，追求完美方案
- 未考虑当前 Week 目标和时间约束

**识别信号**：
- 评估矩阵中"符合原则"得分 <5
- 推荐方案需要 >2 周实现（超出当前 Week）
- 推荐方案违反编码规范或架构约束

**缓解措施**：
- ✅ 评估前检查 8 维矩阵的"符合原则"维度
- ✅ 如果"符合原则" <5 分 → 直接否决该方案
- ✅ 参考：000, 204, 205, 206 规则文件
- ✅ 当前 Week 目标：参考 001-project-context.mdc

---

## 📖 使用示例

### 完整流程演示

**用户提问**：
> "我想实现训练计划的离线编辑功能，但不确定是用本地队列、实时同步还是混合方案。另外，冲突解决策略也不确定是用 Last Write Wins 还是 CRDT。"

**AI 响应**：

```markdown
我发现这是一个复杂问题，涉及 **2 个关键疑点**：
1. 离线编辑的数据同步策略
2. 冲突解决机制的选择

是否使用结构化决策流程？这将帮助我们：
- 系统性地分析每个疑点
- 对比多个方案的优劣（8 维评估）
- 基于证据做出推荐

如需更深入的决策支持框架（评估矩阵、风险分析、案例参考），
我可以加载 208-decision-support-detailed.mdc。
```

**用户确认**：
> "好的，使用结构化流程，加载详细版。"

**AI 执行流程**：

```markdown
✅ 已加载 208-decision-support-detailed.mdc

---

## 1️⃣ 疑点识别

我识别出 2 个关键疑点需要逐一分析：

- ❓ **疑点 1**: 离线编辑的数据同步策略 - 如何在离线编辑和云端同步之间平衡性能和一致性？
- ❓ **疑点 2**: 冲突解决机制 - 如何处理多设备编辑同一数据时的冲突？

按重要性排序：疑点 1 优先（决定整体架构），疑点 2 依赖疑点 1 的结果。

---

## 2️⃣ 方案矩阵

#### ❓ 疑点 1: 离线编辑的数据同步策略

| 评估维度 | 权重 | 方案 A: 本地队列 | 方案 B: 实时同步 | 方案 C: 混合方案 | 说明 |
|---------|------|-----------------|-----------------|-----------------|------|
| **技术可行性** | 20% | 9 | 7 | 6 | A: 简单队列；B: 需 WebSocket；C: 复杂 |
| **实现成本** | 15% | 9 | 5 | 4 | A: 3天；B: 1周；C: 2周 |
| **时间紧迫度** | 15% | 10 | 6 | 5 | A: 符合 Week 8；B: 延迟；C: 不适合 |
| **风险等级** | 15% | 8 | 6 | 5 | A: 低；B: 中（网络依赖）；C: 高 |
| **可维护性** | 10% | 8 | 7 | 5 | A: 清晰；B: 中等；C: 复杂 |
| **可扩展性** | 10% | 7 | 9 | 8 | A: 可扩展；B: 最优；C: 灵活 |
| **用户价值** | 10% | 9 | 8 | 9 | A: 离线优先；B: 实时；C: 兼顾 |
| **符合原则** | 5% | 10 | 10 | 8 | A/B: 符合；C: 复杂度高 |
| **综合得分** | - | **8.9** ⭐⭐⭐⭐⭐ | **7.0** ⭐⭐⭐ | **6.2** ⭐⭐⭐ | - |

**💡 推荐**: 方案 A（本地队列 + 后台同步）

**📝 推荐理由**:
1. **技术可行性高** - 基于 PendingSyncOperation 队列（ADR-010 已验证）
2. **离线优先** - 符合产品原则，用户体验最优（不阻塞 UI）
3. **实现成本低** - 3 天完成，符合 Week 8 目标
4. **风险可控** - 已有 ADR 和实施方案，无未知风险

**⚠️ 不推荐理由**:
- **方案 B**: 实时同步依赖网络，离线场景不可用，违反"离线优先"原则
- **方案 C**: 混合方案过度设计，实现复杂（2 周），不符合 MVP 原则

**📊 证据支持**:
- ADR-010: 离线同步策略（已决策使用队列方案）
- Performance: 队列方案满足 <100ms 写入要求

---

**🗳️ 疑点 1 决策**：请确认是否采用方案 A？
```

**用户确认**：
> "同意方案 A。"

**AI 继续**：

```markdown
✅ 疑点 1 已决策：方案 A（本地队列 + 后台同步）

---

#### ❓ 疑点 2: 冲突解决机制

| 评估维度 | 权重 | 方案 A: Last Write Wins | 方案 B: CRDT | 说明 |
|---------|------|------------------------|--------------|------|
| **技术可行性** | 20% | 10 | 4 | A: 简单时间戳；B: 复杂算法 |
| **实现成本** | 15% | 10 | 3 | A: 1天；B: 2周+ |
| **时间紧迫度** | 15% | 10 | 3 | A: 符合 MVP；B: 严重延迟 |
| **风险等级** | 15% | 8 | 5 | A: 可能丢失数据；B: 算法复杂 |
| **可维护性** | 10% | 9 | 4 | A: 简单清晰；B: 难以理解 |
| **可扩展性** | 10% | 6 | 10 | A: 受限；B: 最优 |
| **用户价值** | 10% | 7 | 9 | A: 够用；B: 无冲突 |
| **符合原则** | 5% | 10 | 8 | A: 符合 MVP；B: 过度设计 |
| **综合得分** | - | **9.1** ⭐⭐⭐⭐⭐ | **5.3** ⭐⭐ | - |

**💡 推荐**: 方案 A（Last Write Wins）

**📝 推荐理由**:
1. **符合 MVP 原则** - ADR-010 已明确 MVP 阶段使用 Last Write Wins
2. **实现简单** - 基于毫秒级时间戳，1 天完成
3. **风险可控** - 训练计划冲突概率低（单用户单设备为主）
4. **可升级** - 未来如有需求，可升级到 CRDT（保留接口）

**⚠️ 不推荐理由**:
- **方案 B**: CRDT 过度设计，实现复杂（2 周+），不符合 204 原则
  - 当前阶段无数据支持多设备冲突频繁
  - 训练计划编辑不是高并发场景（非协同文档）

**📊 证据支持**:
- ADR-010: "MVP 阶段统一使用 Last Write Wins"
- 用户场景分析：80% 用户单设备，20% 双设备极少同时编辑

---

**🗳️ 疑点 2 决策**：请确认是否采用方案 A？
```

**用户确认**：
> "确认，使用 Last Write Wins。"

**AI 综合整合**：

```markdown
✅ 所有疑点已决策完成

---

## 📊 决策摘要

| 疑点 | 最终方案 | 关键决策依据 |
|------|---------|-------------|
| 疑点 1: 数据同步策略 | 方案 A: 本地队列 | 离线优先 + 技术可行性高 + ADR-010 |
| 疑点 2: 冲突解决 | 方案 A: Last Write Wins | MVP 原则 + 低冲突概率 + ADR-010 |

---

## 📝 实施计划大纲

### Phase 1: 本地队列实现（1-2 天）
- [ ] Step 1: 创建 PendingSyncOperation Model
- [ ] Step 2: 实现队列管理 Service
- [ ] Step 3: 集成到 TrainingPlan 保存流程

### Phase 2: 冲突解决逻辑（1 天）
- [ ] Step 4: 实现 Last Write Wins 比较逻辑
- [ ] Step 5: 添加时间戳字段（lastModifiedMs）
- [ ] Step 6: 更新 Firebase Sync 逻辑

### Phase 3: 测试与验证（1 天）
- [ ] Step 7: 单元测试（队列 + 冲突解决）
- [ ] Step 8: 集成测试（离线编辑 → 上线同步）
- [ ] Step 9: 真机测试（多设备场景）

**预计总时间**: 3-4 天

---

## ⚠️ 综合风险清单

| 风险 | 可能性 | 影响 | 风险等级 | 缓解措施 | 应急预案 |
|------|--------|------|---------|---------|---------|
| 队列过大内存溢出 | 🟡 中 | 🟠 中 | 🟠 中 | 限制队列大小（100条） | 清理旧数据 |
| Last Write Wins 丢失数据 | 🟢 低 | 🟠 中 | 🟢 低 | 用户教育（提示同步状态） | 未来升级 CRDT |
| 时间戳不一致（设备时间错误） | 🟢 低 | 🟡 低 | 🟢 低 | 使用服务器时间戳 | 客户端校准 |

---

## 📄 关联文档

- ADR: `docs/03-decisions/ADR-010-offline-sync-strategy.md`（已存在）
- 实施文档: `docs/04-implementation/offline-sync-implementation.md`（待更新）
- Changelog: `docs/07-changelog/2025-11.md`（待记录）

---

## ✅ 下一步

用户批准后，AI 开始执行实施计划（遵循 207-task-execution-detailed.mdc）
```

---

**最后更新**: 2025-11-08  
**版本**: 1.1 🆕  
**Token 估算**: ~3,100 tokens  
**加载方式**: 手动加载（按需）  
**优先级**: 详细参考  

**更新日志 (v1.1)**:
- 🆕 添加"渐进式展示原则"（默认简洁，可选详细）
- 🆕 添加"简化版模板"（用于次要疑点，节省 48% 篇幅）
- 🆕 明确何时展开/折叠评估表格的指导
- 🆕 添加"评估摘要"格式（替代完整表格）
- ✨ 优化易读性和用户体验
