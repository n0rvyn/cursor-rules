---
description: "127: Swift 6 concurrency best practices with strict data race safety"
scopes: [chat, edit]
tags: [swift6, concurrency, actors, sendable, data-race-safety, ios18]
priority: 127
globs:
  - "**/*.swift"
  - "**/*.swiftui"
alwaysApply: false
---

# Swift 6 Concurrency & Data Race Safety

You are working with Swift 6's strict concurrency model. Follow these patterns to eliminate data races at compile time and write safe concurrent code.

## üéØ Strict Concurrency Mode

### Enabling Swift 6 Mode
**Build Settings ‚Üí Swift Language Version ‚Üí 6**

**Incremental Adoption**:
```swift
// Start with warnings
// Build Settings ‚Üí Swift Compiler - Upcoming Features
// - Enable "Strict Concurrency" ‚Üí Minimal/Targeted

// Then enable complete checking
// Swift Language Version ‚Üí 6
```

### Key Principles
- **Data races are compiler errors** not runtime crashes
- **All shared mutable state** must be protected
- **Sendable conformance** required for cross-boundary types
- **Actor isolation** enforced at compile time

## üèóÔ∏è Actors for Shared Mutable State

### Basic Actor Pattern
```swift
actor DataCache {
    private var cache: [String: Data] = [:]

    func store(_ data: Data, forKey key: String) {
        cache[key] = data
    }

    func retrieve(forKey key: String) -> Data? {
        return cache[key]
    }

    func clear() {
        cache.removeAll()
    }
}

// Usage
let cache = DataCache()
await cache.store(imageData, forKey: "profile")
let data = await cache.retrieve(forKey: "profile")
```

### Actor with Synchronous Methods
```swift
actor UserSession {
    private var currentUser: User?

    // Async methods cross actor boundary
    func setUser(_ user: User) {
        currentUser = user
    }

    // Nonisolated for non-mutating access to immutable state
    nonisolated func getUserID() -> UUID? {
        return currentUser?.id  // Error if currentUser is mutable
    }
}
```

### Custom Executors
```swift
actor DatabaseActor {
    nonisolated let unownedExecutor: UnownedSerialExecutor

    init(executor: UnownedSerialExecutor) {
        self.unownedExecutor = executor
    }

    func performQuery() {
        // Runs on custom executor
    }
}
```

## üåç Global Actors

### @MainActor for UI Code
```swift
// Mark entire class
@MainActor
class ViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false

    // All methods run on main actor by default
    func loadItems() async {
        isLoading = true
        defer { isLoading = false }

        // Background work
        let items = await fetchItems()

        // UI update (already on MainActor)
        self.items = items
    }

    // Opt-out for specific methods
    nonisolated func backgroundTask() async {
        // Runs off main actor
    }
}
```

### Mixed Actor Isolation
```swift
class DataService {
    @MainActor
    func updateUI(_ data: Data) {
        // UI updates
    }

    func processInBackground() async {
        // Background work
        let processed = await heavyProcessing()

        // Jump to main actor for UI update
        await updateUI(processed)
    }
}
```

### Custom Global Actors
```swift
@globalActor
actor DatabaseActor {
    static let shared = DatabaseActor()
}

@DatabaseActor
class DatabaseManager {
    func query() async -> [Result] {
        // All access serialized through DatabaseActor
    }
}
```

## üì¶ Sendable Protocol

### Implicit Sendable
```swift
// Value types with Sendable members are implicitly Sendable
struct User: Sendable {
    let id: UUID
    let name: String
    let email: String
}

// Frozen enums are Sendable
enum NetworkError: Error, Sendable {
    case timeout
    case invalidResponse
    case serverError(Int)
}
```

### Explicit Sendable Conformance
```swift
// Final classes with only immutable Sendable properties
final class Configuration: Sendable {
    let apiKey: String
    let baseURL: URL

    init(apiKey: String, baseURL: URL) {
        self.apiKey = apiKey
        self.baseURL = baseURL
    }
}
```

### @unchecked Sendable
**Use ONLY when you've manually verified thread safety**:
```swift
final class ThreadSafeCache: @unchecked Sendable {
    private let lock = NSLock()
    private var storage: [String: Any] = [:]

    func set(_ value: Any, forKey key: String) {
        lock.lock()
        defer { lock.unlock() }
        storage[key] = value
    }

    func get(forKey key: String) -> Any? {
        lock.lock()
        defer { lock.unlock() }
        return storage[key]
    }
}
```

### Sendable Closures
```swift
// Closures are Sendable if they only capture Sendable values
func processAsync(_ handler: @Sendable @escaping () -> Void) {
    Task {
        handler()
    }
}

// Sendable requirement
let name = "John"  // String is Sendable
processAsync {
    print("Hello, \(name)")  // ‚úÖ OK
}

var counter = 0  // Not Sendable (mutable)
processAsync {
    counter += 1  // ‚ùå Error: Mutation of captured var
}
```

## üîÑ Task and Task Groups

### Basic Tasks
```swift
func loadData() async {
    // Start concurrent tasks
    async let users = fetchUsers()
    async let posts = fetchPosts()
    async let comments = fetchComments()

    // Wait for all
    let (userList, postList, commentList) = await (users, posts, comments)
}
```

### Task Groups for Dynamic Concurrency
```swift
func fetchMultipleItems(ids: [String]) async throws -> [Item] {
    try await withThrowingTaskGroup(of: Item.self) { group in
        for id in ids {
            group.addTask {
                try await fetchItem(id: id)
            }
        }

        var items: [Item] = []
        for try await item in group {
            items.append(item)
        }
        return items
    }
}
```

### Task Cancellation
```swift
func cancellableOperation() async throws {
    try await withTaskCancellationHandler {
        // Main operation
        for i in 0..<1000 {
            try Task.checkCancellation()
            await processItem(i)
        }
    } onCancel: {
        // Cleanup on cancellation
        cleanup()
    }
}
```

### Task Priority
```swift
Task(priority: .userInitiated) {
    await loadCriticalData()
}

Task(priority: .background) {
    await performAnalytics()
}
```

## üö® Common Data Race Patterns & Fixes

### Pattern 1: Shared Mutable State
**‚ùå Problem**:
```swift
class DataStore {
    var items: [Item] = []  // ‚ö†Ô∏è Data race

    func addItem(_ item: Item) {
        items.append(item)
    }
}
```

**‚úÖ Solution 1: Use Actor**:
```swift
actor DataStore {
    var items: [Item] = []

    func addItem(_ item: Item) {
        items.append(item)
    }
}
```

**‚úÖ Solution 2: Use @MainActor if UI-related**:
```swift
@MainActor
class DataStore: ObservableObject {
    @Published var items: [Item] = []

    func addItem(_ item: Item) {
        items.append(item)
    }
}
```

### Pattern 2: Closure Captures
**‚ùå Problem**:
```swift
var results: [String] = []
Task {
    results.append("data")  // ‚ö†Ô∏è Data race
}
```

**‚úÖ Solution: Use Actor or MainActor**:
```swift
actor ResultStore {
    private(set) var results: [String] = []

    func add(_ result: String) {
        results.append(result)
    }
}

let store = ResultStore()
Task {
    await store.add("data")
}
```

### Pattern 3: Property Access from Different Contexts
**‚ùå Problem**:
```swift
@MainActor
class ViewModel: ObservableObject {
    @Published var data: [Item] = []

    func load() async {
        Task {  // Runs on background
            data = await fetchData()  // ‚ùå MainActor-isolated property accessed from nonisolated
        }
    }
}
```

**‚úÖ Solution: Use proper isolation**:
```swift
@MainActor
class ViewModel: ObservableObject {
    @Published var data: [Item] = []

    func load() async {
        // Already on MainActor
        data = await fetchData()
    }
}
```

## üîç Isolation Patterns

### Isolated Parameters
```swift
@MainActor
func updateUI(with data: Data) {
    // Update UI
}

func processData() async {
    let data = await fetchData()

    // Call MainActor function
    await updateUI(with: data)
}
```

### Nonisolated for Safe Access
```swift
@MainActor
class ViewModel {
    private let configuration: Configuration  // Immutable Sendable

    nonisolated var apiKey: String {
        configuration.apiKey  // ‚úÖ Safe: accessing immutable Sendable property
    }
}
```

### Isolation Inheritance
```swift
@MainActor
protocol ViewModelProtocol {
    func loadData() async
}

// Inherits @MainActor isolation
class MyViewModel: ViewModelProtocol {
    func loadData() async {
        // Runs on MainActor
    }
}
```

## üõ†Ô∏è Migration Strategies

### Step 1: Enable Warnings
```swift
// Build Settings ‚Üí Swift Compiler - Upcoming Features
// Strict Concurrency = Minimal
```

### Step 2: Fix One Module at a Time
```swift
// For problematic imports
@preconcurrency import OldFramework

// This suppresses warnings from the imported module
```

### Step 3: Gradual Actor Adoption
```swift
// Start with @MainActor for UI code
@MainActor
class ViewController { }

// Add custom actors for specific subsystems
actor DatabaseManager { }
actor NetworkManager { }
```

### Step 4: Enable Full Checking
```swift
// Switch to Swift 6 language mode
// Build Settings ‚Üí Swift Language Version ‚Üí 6
```

## üß™ Testing Concurrent Code

### Test with Main Actor
```swift
@Test("Data loads correctly")
@MainActor
func testDataLoading() async throws {
    let viewModel = ViewModel()
    await viewModel.loadData()
    #expect(viewModel.items.count > 0)
}
```

### Test Actor Isolation
```swift
@Test("Cache stores data correctly")
func testCache() async throws {
    let cache = DataCache()
    await cache.store(testData, forKey: "test")
    let retrieved = await cache.retrieve(forKey: "test")
    #expect(retrieved == testData)
}
```

## üìã Best Practices Summary

### DO ‚úÖ
- **Use actors** for shared mutable state
- **Use @MainActor** for all UI code
- **Conform to Sendable** for types crossing boundaries
- **Use `async let`** for concurrent operations
- **Check cancellation** in long-running tasks
- **Enable Swift 6 mode** for new projects

### DON'T ‚ùå
- **Share mutable state** without protection
- **Use @unchecked Sendable** unless absolutely necessary
- **Access MainActor properties** from background contexts
- **Ignore compiler warnings** about isolation
- **Use legacy completion handlers** when async/await is available

## üîó Common Errors & Solutions

### Error: "Expression is 'async' but is not marked with 'await'"
```swift
// ‚ùå
func fetchData() async -> Data { }
let data = fetchData()  // Error

// ‚úÖ
let data = await fetchData()
```

### Error: "Call to main actor-isolated property from non-isolated context"
```swift
// ‚ùå
Task {
    viewModel.items = []  // Error if viewModel is @MainActor
}

// ‚úÖ
await MainActor.run {
    viewModel.items = []
}
```

### Error: "Type 'X' does not conform to 'Sendable'"
```swift
// ‚ùå
class DataModel {
    var id: String
}

// ‚úÖ
struct DataModel: Sendable {
    let id: String
}
```

---

**Remember**: Swift 6's strict concurrency checking eliminates entire classes of bugs. Embrace the compiler errors - they're preventing data races that would crash your app in production.
