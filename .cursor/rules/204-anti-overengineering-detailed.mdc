---
description: "é˜²æ­¢è¿‡åº¦è®¾è®¡ - è¯æ®ä¼˜å…ˆä¸å¤æ‚åº¦æ§åˆ¶ - è¯¦ç»†å‚è€ƒ"
scopes: [chat, edit]
tags: [anti-overengineering, evidence-first, complexity, decision-making, detailed-reference]
priority: 204
globs: []
alwaysApply: false
---

# é˜²æ­¢è¿‡åº¦è®¾è®¡ - è¯æ®ä¼˜å…ˆä¸å¤æ‚åº¦æ§åˆ¶ï¼ˆè¯¦ç»†å‚è€ƒï¼‰

> **æ³¨æ„**ï¼šæœ¬æ–‡ä»¶ä¸ºè¯¦ç»†å‚è€ƒï¼Œä¸ä¼šè‡ªåŠ¨åŠ è½½ã€‚  
> **è¾¨è¯æ€è€ƒé“å¾‹**ï¼šè§ `000-critical-rules.mdc` çš„"AI å·¥ä½œåŸåˆ™"éƒ¨åˆ†

---

> **æ ¸å¿ƒåŸåˆ™**: æ¯ä¸ªå†³ç­–å¿…é¡»æœ‰è¯æ®æ”¯æŒï¼Œä¼˜å…ˆä½¿ç”¨ç°æœ‰æ¨¡å¼ï¼Œé¿å…ä¸å¿…è¦çš„å¤æ‚æ€§

---

## ğŸ¯ æ ¸å¿ƒåŸåˆ™

> **"Every decision must be backed by evidence from existing code, documentation, or verified sources."**

### ä¸‰å¤§æ”¯æŸ±
1. **è¯æ®ä¼˜å…ˆ** - åŸºäºç°æœ‰ä»£ç å’Œæ–‡æ¡£åšå†³ç­–
2. **å¤æ‚åº¦æ§åˆ¶** - é»˜è®¤é€‰æ‹©æœ€ç®€å•çš„è§£å†³æ–¹æ¡ˆï¼ˆâ‰¤3/10 å¤æ‚åº¦ï¼‰
3. **æ¨¡å¼ä¸€è‡´æ€§** - éµå¾ªé¡¹ç›®ç°æœ‰æ¨¡å¼ï¼Œä¸éšæ„åˆ›æ–°

---

## ğŸ“‹ Evidence-First å†³ç­–æµç¨‹

### Before Proposing Any Solution

**å¿…é¡»å®Œæˆçš„æ­¥éª¤**ï¼š

1. **Find Existing Code** - æ‰¾åˆ° 2-3 ä¸ªç±»ä¼¼å®ç°çš„ä¾‹å­
2. **Cite Sources** - æä¾›æ–‡ä»¶è·¯å¾„å’Œè¡Œå·
3. **Explain Patterns** - æè¿°ç°æœ‰ä»£ç å¦‚ä½•å·¥ä½œ
4. **Justify Deviations** - è§£é‡Šä¸ºä»€ä¹ˆç°æœ‰æ¨¡å¼ä¸é€‚ç”¨ï¼ˆå¦‚æœåç¦»ï¼‰

### Evidence Quality Standards

| è¯æ®ç±»å‹ | ä¼˜å…ˆçº§ | è¯´æ˜ |
|---------|--------|------|
| **Primary Evidence** | â­â­â­â­â­ | é¡¹ç›®ä¸­ç°æœ‰çš„å·¥ä½œä»£ç  |
| **Secondary Evidence** | â­â­â­â­ | Apple å®˜æ–¹æ–‡æ¡£ã€Framework æ–‡æ¡£ |
| **Tertiary Evidence** | â­â­â­ | ç¤¾åŒºæœ€ä½³å®è·µï¼ˆéœ€éªŒè¯ï¼‰ |
| **Never Accept** | âŒ | å‡è®¾ã€"å¸¸è¯†"ã€æœªç»æ”¯æŒçš„å£°æ˜ |

---

## ğŸš¨ Pre-Implementation Checks

### Rule 1: Evidence-First Analysis

**Before implementing ANY solution:**

```markdown
1. âœ… Find existing working code that solves similar problems
   - File: `Epoch/Services/HealthKitService.swift:45-67`
   - Pattern: Uses `@MainActor` + `Actor` for concurrency
   
2. âœ… Cite file paths + line numbers
   - Show me the exact code reference
   
3. âœ… Show me the existing pattern
   - How does it currently work?
   - What dependencies does it have?
   
4. âœ… Explain WHY that pattern won't work for this case
   - Be specific about the limitations
   - Provide evidence, not assumptions
   
5. âœ… Only then propose minimal changes
   - Build on existing patterns
   - Minimize new abstractions
```

### Rule 2: Complexity Rating System

**Rate every solution complexity 1-10:**

| Rating | Category | Action Required |
|--------|----------|----------------|
| **1-3** | ç®€å•ï¼ˆé¦–é€‰ï¼‰ | ä½¿ç”¨ç°æœ‰æ¨¡å¼ï¼Œç›´æ¥å®ç° |
| **4-6** | ä¸­ç­‰ | éœ€è¦ä¹¦é¢è¯´æ˜ç†ç”± |
| **7-10** | å¤æ‚ | éœ€è¦æ˜ç¡®æ‰¹å‡† + ADR |

**DEFAULT**: Always choose â‰¤3/10 complexity solutions

**Example:**
```markdown
COMPLEXITY ASSESSMENT:
- Solution Complexity: 2/10
- Justification: Reuses existing HealthKitService pattern, only adds one new function
- Existing Pattern: Similar to `fetchWorkouts()` in HealthKitService.swift:45-67
```

### Rule 3: Simplicity Challenge

**If solution has >3 implementation steps:**

```markdown
1. â“ Justify why 1-step solution won't work
   - Show evidence that simpler approach fails
   
2. â“ Justify why 2-step solution won't work
   - Explain what additional complexity is needed
   
3. â“ Show evidence that 3+ steps are actually needed
   - Cite similar complex solutions in codebase
   
4. âœ‹ Get explicit approval before proceeding
   - Wait for user confirmation
```

### Rule 4: Pattern Compliance

**For any new implementation:**

```markdown
1. âœ… Find 2-3 existing similar patterns in codebase
   - HealthKitService.swift: Uses Actor for thread safety
   - FirebaseService.swift: Uses Protocol + Mock pattern
   - TrainingLogViewModel.swift: Uses @MainActor + @Observable
   
2. âœ… Show me how they work
   - Explain the pattern and its benefits
   
3. âœ… Use the SAME pattern unless you can prove it won't work
   - Consistency is more important than "better" approaches
   
4. âœ… If deviating from pattern, get explicit approval
   - Explain why deviation is necessary
   - Provide evidence that existing pattern fails
```

---

## ğŸ” Evidence Collection Process

### Step 1: Search for Existing Patterns

```bash
# Use these tools to find similar implementations
grep -r "similar_pattern" Epoch/
grep -r "related_functionality" Epoch/Services/

# Or use semantic search
# "How does X work in this project?"
# "Where is similar functionality implemented?"
```

### Step 2: Analyze Existing Code

**Documentation Format:**
```markdown
EVIDENCE FOUND:
- File: `Epoch/Services/HealthKitService.swift:45-67`
- Pattern: Uses `@MainActor` + `Actor` for UI updates and thread safety
- Context: Service needs to update UI when data changes
- Dependencies: 
  - Requires `@MainActor` for UI updates
  - Uses `Actor` for background data processing
  - Follows Protocol pattern for dependency injection
```

### Step 3: Document Evidence

**Code Citations:**
```swift
// Based on existing pattern in Epoch/Services/HealthKitService.swift:45-67
// Following the same approach as Epoch/ViewModels/TrainingLogViewModel.swift:23-34
// Using pattern established in Epoch/Models/CachedTrainingLog.swift:12-28
```

**Documentation Citations:**
```swift
// Apple Documentation: https://developer.apple.com/documentation/swiftui/observable
// SwiftData Guide: https://developer.apple.com/documentation/swiftdata
// WWDC 2023 Session: "Meet SwiftData"
```

---

## ğŸš« Prohibited Without Evidence

### Don't Assume

```markdown
âŒ "This pattern is wrong" (without showing why)
âŒ "This is the standard way" (without documentation)
âŒ "This will cause problems" (without evidence)
âŒ "This is better" (without comparison)
```

### Don't Invent

```markdown
âŒ New patterns without existing examples
âŒ New APIs without documentation
âŒ New architectures without justification
âŒ New conventions without precedent
```

**Example of BAD approach:**
```markdown
"We should use a Coordinator pattern for navigation."
âŒ No evidence that current NavigationStack approach is failing
âŒ No similar Coordinator pattern in existing codebase
âŒ Adds complexity without proven benefit
```

**Example of GOOD approach:**
```markdown
"We should continue using NavigationStack for navigation."
âœ… Currently used in TrainingLogView.swift:12-45
âœ… Apple's recommended approach (WWDC 2022)
âœ… Complexity: 2/10 (simple, consistent)
âœ… Works well for our use case
```

---

## âœ… Required With Evidence

### Always Show

```markdown
âœ… Existing working code that solves similar problems
âœ… File paths and line numbers for all references
âœ… Explanation of how existing patterns work
âœ… Justification for any deviations from existing patterns
```

### Always Cite

```markdown
âœ… Official documentation for all API usage
âœ… Existing project patterns for all architectural decisions
âœ… Verified sources for all best practices
âœ… Specific examples for all recommendations
```

---

## ğŸ“‹ Evidence Templates

### Existing Code Analysis

```markdown
EXISTING PATTERN ANALYSIS:
- File: `Epoch/Services/HealthKitService.swift`
- Lines: 45-67
- Pattern: Actor-based service with @MainActor for UI updates
- Context: Needs thread-safe access to HealthKit + UI updates
- Dependencies: HKHealthStore, ModelContext (via @MainActor)
- Similarity: Solving same problem - async data fetch + UI update

CONCLUSION:
- Reuse this pattern âœ…
- Complexity: 2/10
- No new abstractions needed
```

### Solution Justification

```markdown
SOLUTION JUSTIFICATION:
- Based on: `Epoch/Services/HealthKitService.swift:45-67`
- Pattern: Actor + @MainActor
- Adaptation: Add new `fetchIncrementalWorkouts()` method
- Evidence: Same concurrency pattern, proven to work
- Complexity: 2/10 (minimal change to existing service)
```

### Deviation Justification

```markdown
DEVIATION JUSTIFICATION:
- Existing pattern: All Services use Actor isolation
- Why it won't work: This service needs to be @MainActor throughout
- Reason: Heavy UI interaction, needs direct access to @MainActor properties
- Alternative approach: Use @MainActor class instead of Actor
- Evidence: Similar pattern in Apple's sample code (link)
- Complexity: 4/10 (deviation from project pattern)
- Approval Required: âœ… Yes (>3/10 complexity + pattern deviation)
```

---

## ğŸ¯ Quality Gates

### Before Implementation

- [ ] **Evidence collected**: Found 2-3 existing similar patterns
- [ ] **Sources cited**: All references include file paths/line numbers
- [ ] **Patterns understood**: Can explain how existing code works
- [ ] **Complexity rated**: Solution rated 1-10, justified if >3
- [ ] **Pattern compliance**: Using existing project patterns
- [ ] **Justification complete**: Can explain why approach is appropriate

### During Implementation

- [ ] **Following evidence**: Implementation matches cited patterns
- [ ] **Maintaining consistency**: Using same approaches as existing code
- [ ] **Documenting decisions**: Adding comments explaining choices
- [ ] **No over-engineering**: Not adding unnecessary abstractions

### After Implementation

- [ ] **Verification complete**: Solution works as expected
- [ ] **Pattern consistency**: Follows established project patterns
- [ ] **Documentation updated**: Changes properly documented
- [ ] **No regressions**: Existing functionality still works

---

## ğŸš¨ Violation Consequences

### Missing Evidence

| Violation Type | Response |
|---------------|----------|
| **First violation** | Request evidence before proceeding |
| **Repeated violations** | Require evidence for all future decisions |
| **Pattern violations** | Require explicit approval for any deviations |

### False Evidence

| Issue Type | Action |
|-----------|--------|
| **Incorrect citations** | Correct immediately and verify all other citations |
| **Misleading patterns** | Explain actual pattern and adjust solution |
| **Outdated references** | Update to current documentation/patterns |

---

## ğŸ“š Epoch Project Evidence Sources

### Primary Sources (Existing Code)
- **Services**: `Epoch/Services/` - HealthKit, Firebase, Backend integrations
- **ViewModels**: `Epoch/ViewModels/` - MVVM pattern examples
- **Models**: `Epoch/Models/` - SwiftData models with `Cached` prefix
- **Views**: `Epoch/Views/` - SwiftUI view patterns

### Secondary Sources (Documentation)
- **Architecture**: `docs/02-architecture.md`
- **ADRs**: `docs/03-decisions/` - Architectural decisions with rationale
- **Implementation**: `docs/04-implementation/` - Detailed implementation guides
- **Coding Standards**: `docs/08-guidelines/coding-standards.md`

### External Sources
- **Apple Documentation**: https://developer.apple.com/documentation/
- **SwiftData Guide**: https://developer.apple.com/documentation/swiftdata
- **SwiftUI Documentation**: https://developer.apple.com/documentation/swiftui
- **HealthKit**: https://developer.apple.com/documentation/healthkit

---

## ğŸ“Š Practical Examples

### âœ… Good Example: Following Existing Pattern

```markdown
USER: "We need to add a new method to fetch workouts from last week."

AI RESPONSE:
EVIDENCE ANALYSIS:
- Existing: `HealthKitService.swift:45-67` has `fetchRecentWorkouts(limit:)`
- Pattern: Actor-based service with async/await
- Complexity: 2/10 (add one similar method)

PROPOSED SOLUTION:
```swift
// Based on existing pattern in HealthKitService.swift:45-67
actor HealthKitService {
    func fetchWorkoutsFromLastWeek() async throws -> [HKWorkout] {
        let oneWeekAgo = Date().addingTimeInterval(-7 * 24 * 3600)
        return try await fetchIncrementalWorkouts(since: oneWeekAgo)
    }
}
```

JUSTIFICATION:
- Reuses existing `fetchIncrementalWorkouts()` method
- Follows same Actor pattern
- No new abstractions needed
```

### âŒ Bad Example: Over-Engineering

```markdown
USER: "We need to add a new method to fetch workouts from last week."

AI RESPONSE (DON'T DO THIS):
"Let's create a new WorkoutQueryBuilder pattern with a fluent API:

```swift
WorkoutQuery.builder()
    .timeRange(.lastWeek)
    .activityType(.running)
    .sortBy(.date, .descending)
    .execute()
```

This is more flexible and scalable..."

WHY THIS IS BAD:
âŒ No evidence of similar pattern in codebase
âŒ Adds unnecessary complexity (7/10 complexity)
âŒ Over-engineering a simple requirement
âŒ Invents new pattern without justification
```

---

**Remember**: Evidence-first approach prevents overengineering, ensures consistency, and builds on proven patterns rather than inventing new solutions. When in doubt, use existing patterns and keep it simple.

---

**æœ€åæ›´æ–°**: 2025-11-03  
**ç‰ˆæœ¬**: 1.0  
**åŸºäº**: `006-anti-overengineering.mdc` + `008-evidence-first.mdc`


