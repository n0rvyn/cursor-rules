---
description: "ç¦»çº¿åŒæ­¥ä¸å†²çªè§£å†³ - æ£€æŸ¥æ¸…å•"
scopes: [chat, edit]
tags: [offline-sync, conflict-resolution, checklist]
priority: 103
globs: ["**/*Sync*.swift"]
alwaysApply: false
---

# ç¦»çº¿åŒæ­¥æ£€æŸ¥æ¸…å•

> **è§¦å‘æ¡ä»¶**: ç¼–è¾‘åŒæ­¥ç›¸å…³æ–‡ä»¶æ—¶è‡ªåŠ¨åŠ è½½  
> **è¯¦ç»†å‚è€ƒ**: `docs/03-decisions/ADR-010-offline-sync-strategy.md`

---

## ğŸ”´ æ ¸å¿ƒçº¦æŸ

### å†²çªè§£å†³è§„åˆ™ â­â­â­â­â­

#### MVP é˜¶æ®µï¼ˆWeek 1-12ï¼‰

**ç»Ÿä¸€ç­–ç•¥**ï¼šæ‰€æœ‰æ•°æ®ç±»å‹ä½¿ç”¨ **Last Write Wins**

```swift
// åŸºäºæ¯«ç§’çº§æ—¶é—´æˆ³åˆ¤æ–­
func resolveConflict<T>(local: T, remote: T) -> T where T: Syncable {
    return local.lastModifiedMs > remote.lastModifiedMs ? local : remote
}
```

#### V1.1 å®ç°ï¼ˆæœªæ¥ï¼‰

| æ•°æ®ç±»å‹ | å†²çªç­–ç•¥ | åŸå›  |
|---|---|---|
| è®­ç»ƒè®°å½• (Log) | Last Write Wins | ç”¨æˆ·æ•°æ®ï¼Œä»¥æœ€æ–°ä¸ºå‡† |
| è®­ç»ƒè®¡åˆ’ (Plan) | Server Wins | AI ç”Ÿæˆï¼ŒæœåŠ¡ç«¯æƒå¨ |
| ç”¨æˆ·é…ç½® (Profile) | Merge | å­—æ®µçº§åˆå¹¶ |

### ç¦»çº¿ä¼˜å…ˆåŸåˆ™ï¼ˆæ‰€æœ‰é˜¶æ®µï¼‰

```swift
// 1. è¯»å–ä¼˜å…ˆæœ¬åœ°ï¼ˆ<100msï¼‰
let logs = try modelContext.fetch(descriptor)

// 2. å†™å…¥å…ˆå­˜æœ¬åœ°ï¼ˆä¸é˜»å¡ç”¨æˆ·ï¼‰
modelContext.insert(newLog)
try modelContext.save()

// 3. åå°è‡ªåŠ¨åŒæ­¥ï¼ˆæ£€æµ‹ç½‘ç»œåä¸Šä¼ ï¼‰
Task.detached {
    try await syncService.uploadPendingChanges()
}

// 4. ä½¿ç”¨ PendingSyncOperation é˜Ÿåˆ—ç®¡ç†æœªåŒæ­¥æ•°æ®
let operation = PendingSyncOperation(
    entityType: .trainingLog,
    operation: .create,
    payload: logData
)
modelContext.insert(operation)
```

---

## ğŸ“‹ æ“ä½œæ­¥éª¤æ¨¡æ¿

### ä¿å­˜æ•°æ®ï¼ˆç¦»çº¿ä¼˜å…ˆï¼‰

```swift
// Step 1: å…ˆå­˜æœ¬åœ°
let log = CachedTrainingLog(...)
log.lastModifiedMs = Date().timeIntervalSince1970 * 1000
modelContext.insert(log)
try modelContext.save()

// Step 2: åˆ›å»º PendingSyncOperation
let operation = PendingSyncOperation(
    entityType: "TrainingLog",
    operation: "create",
    entityId: log.id,
    payload: try JSONEncoder().encode(log.toDTO()),
    timestamp: Date()
)
modelContext.insert(operation)
try modelContext.save()

// Step 3: åå°åŒæ­¥
Task.detached {
    try await syncService.processPendingOperations()
}
```

### å†²çªè§£å†³ï¼ˆLast Write Winsï¼‰

```swift
func syncTrainingLog(localLog: CachedTrainingLog, remoteDTO: TrainingLogDTO) throws {
    // MVP: ç®€å•æ¯”è¾ƒæ—¶é—´æˆ³
    if remoteDTO.lastModifiedMs > localLog.lastModifiedMs {
        // æœåŠ¡ç«¯æ›´æ–°
        localLog.updateFrom(dto: remoteDTO)
    } else {
        // æœ¬åœ°æ›´æ–°
        try await firebaseService.saveTrainingLog(localLog.toDTO())
    }
    
    localLog.lastSyncedMs = Date().timeIntervalSince1970 * 1000
    try modelContext.save()
}
```

---

## ğŸ”— è¯¦ç»†å‚è€ƒ

| æ–‡æ¡£ | å†…å®¹ |
|------|------|
| `docs/03-decisions/ADR-010-offline-sync-strategy.md` | â­ å®Œæ•´åŒæ­¥ç­–ç•¥ï¼ˆå¿…è¯»ï¼‰ |

---

**æœ€åæ›´æ–°**: 2025-11-08  
**Token ä¼°ç®—**: ~800 tokens  
**åŠ è½½æ–¹å¼**: Auto-attachï¼ˆglobs åŒ¹é…æ—¶ï¼‰  
**ä¼˜å…ˆçº§**: 103

