---
description: "Swift Type-Check Guardrail: Enforce explicit types and break up complex expressions for better performance and clarity."
scopes: [chat, edit]
tags: [swift, performance, style, clarity]
priority: 124
alwaysApply: false
globs:
  - "**/*.swift"
---

# Rule: Swift Type-Check Guardrail (Performance & Clarity)

## Core Intent
- Always prefer fast, explicit type checking over clever inference.
- Avoid giant single expressions, deep closure nesting, and long builder chains.

When generating or editing Swift code, you MUST follow all of the below guidelines.

## 1. Make Types Explicit
- Add explicit types for local variables with non-trivial initializers, for all closure parameters, and for all return types.
- For overloaded APIs or generics, disambiguate with `as SomeType`, by providing concrete generic arguments, or by using helper wrappers.
- For computed properties and closures, always write the return type explicitly.

## 2. Break Up Heavy Expressions
- **Hard rule**: No single line of code should create more than one collection or view AND transform it in the same statement.
- Split method chains longer than **3 calls** into intermediate, named `let` constants.
- Avoid nested ternaries; use `if` or `guard` statements instead.
- Limit boolean logic chains to **3 terms**; factor out complex conditions into named `let` constants.

## 3. Tame Closures & Generics
- Maximum closure nesting depth is **2**. Extract inner closures into named, private helper functions if a deeper level is required.
- In `map`, `flatMap`, `compactMap`, and `reduce`, keep closure bodies small and focused on a single task. Move complex logic into dedicated helper functions.
- If type inference struggles in a processing pipeline, introduce an intermediate `let` with an explicit type annotation to guide the compiler.

## 4. SwiftUI / Result Builders
- Do not build complex views in a single `body` property. Extract logical sections into smaller, reusable sub-views or computed properties.
- Prefer composing a view from multiple `let` building blocks before arranging them in the final `VStack`, `HStack`, or `Group`.
- If a builder mixes many conditional branches (`if/else`, `switch`), extract the logic for each branch into a helper method that returns `some View`.
- Avoid very long modifier chains. Group them logically (e.g., layout, styling, accessibility) and consider breaking them into steps with intermediate `let` constants.

## 5. Collections & Literals
- Annotate the element types of collections when they are not immediately obvious from the context (e.g., `let items: [MyModel] = [...]`).
- Avoid constructing and transforming a collection in a single, monolithic expression. First, construct the collection and assign it to a variable, then apply transformations on a new line.

## 6. Refactor-on-Warning Recipe
When the Swift compiler warns with a message like “The compiler is unable to type-check this expression in reasonable time”, you MUST auto-apply the following sequence:
1.  Insert explicit types for the left-hand side variable and any closure parameters/returns involved in the expression.
2.  Split the single expression into 2–4 `let` bindings, with each performing only one transformation.
3.  Disambiguate any overloaded function calls using `as SomeType` or by providing explicit generic arguments.
4.  For SwiftUI, move conditional branches or heavily modified components into separate helper properties or sub-views.
5.  Re-evaluate the code. Repeat these steps until the warning disappears.